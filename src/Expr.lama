-- Expression evaluator

import List;
import State;


-- The evaluator itself: takes a state and an expression,
-- returns integer value
--
-- An expression is represented by a data structure of the following shape:
--
-- expr = Var   (string)             |
--        Const (int)                |
--        Binop (string, expr, expr)

fun evalBinop (st, Binop (op, e1, e2)) {
  case op of
    "+" -> (evalExpr (st, e1) + evalExpr (st, e2))
  | "-" -> (evalExpr (st, e1) - evalExpr (st, e2))
  | "*" -> (evalExpr (st, e1) * evalExpr (st, e2))
  | "/"  -> evalExpr (st, e1) /  evalExpr (st, e2)
  | "%"  -> evalExpr (st, e1) %  evalExpr (st, e2)
  | "==" -> evalExpr (st, e1) == evalExpr (st, e2)
  | "!=" -> evalExpr (st, e1) != evalExpr (st, e2)
  | "<"  -> evalExpr (st, e1) <  evalExpr (st, e2)
  | "<=" -> evalExpr (st, e1) <= evalExpr (st, e2)
  | ">"  -> evalExpr (st, e1) >  evalExpr (st, e2)
  | ">=" -> evalExpr (st, e1) >= evalExpr (st, e2)
  | "&&" -> evalExpr (st, e1) && evalExpr (st, e2)
  | "!!" -> evalExpr (st, e1) !! evalExpr (st, e2)
  | _    -> failure (printf("eval unknown Binop: %s\n", op))
  esac
}

public fun evalExpr (st, expr) {
  -- printf("Expr: %s\n", string(expr));
  case expr of
    Var            (s) -> st (s)
  | Const          (n) -> n
  | Binop (op, e1, e2) -> evalBinop (st, expr)
  | _                  -> failure ("invalid expr\n")
  esac
}
